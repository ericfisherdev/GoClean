# Bug Fixes - August 18, 2025

## Issue 1: JSON Format Flag Not Working

### Problem
The CLI exposed a `--format json` option in the help text, but the functionality was not wired up in the code. Users who tried to use `goclean scan --format json` would not get JSON output.

### Root Cause
In `cmd/goclean/main.go`, the format flag accepted "json" as a valid value (line 580), but the command-line flag processing logic (lines 97-114) only handled "html" and "markdown" formats. The JSON reporter infrastructure existed (`internal/reporters/json.go`) and was properly integrated in the reporter manager, but the CLI wasn't setting the configuration to enable it.

### Solution
Added handling for the "json" format in the command-line flag processing:
- When `--format json` is specified, set `cfg.Export.JSON.Enabled = true`
- If an output path is provided with `--output`, use it for `cfg.Export.JSON.Path`
- If no output path is provided, use the default path `./reports/violations.json`

### Changes Made
**File:** `cmd/goclean/main.go` (lines 98-114)
```go
// Override configuration with command-line flags if provided
if format == "json" {
    // Enable JSON export when format is explicitly set to json
    cfg.Export.JSON.Enabled = true
    if outputPath != "" {
        cfg.Export.JSON.Path = outputPath
    } else if cfg.Export.JSON.Path == "" {
        // Use default path if not configured
        cfg.Export.JSON.Path = "./reports/violations.json"
    }
} else if outputPath != "" {
    if format == "html" || format == "" {
        cfg.Output.HTML.Path = outputPath
    } else if format == "markdown" {
        cfg.Output.Markdown.Path = outputPath
        cfg.Output.Markdown.Enabled = true
    }
}
```

### Testing
- `goclean scan --format json` - Generates JSON at default path `./reports/violations.json`
- `goclean scan --format json --output custom.json` - Generates JSON at specified path
- Both commands now work correctly and produce valid JSON output

---

## Issue 2: HTML Template Error - Undefined File Field

### Problem
HTML report generation was failing with the error:
```
failed to execute template: template: report.html:909:138: executing "report.html" at <$.File>: 
can't evaluate field File in type struct { *models.Report; Config *reporters.HTMLConfig; 
GeneratedAt string; FileTree *models.FileTreeNode; RefreshMeta template.HTML }
```

### Root Cause
In the HTML template (`internal/reporters/templates/report.html`), line 909 was using `$.File` to access the file path for language detection. The `$` symbol refers to the root template context, which doesn't have a `File` field. The template was iterating over violations, and each violation object has its own `File` field that should be accessed directly.

### Solution
Changed the template to use `.File` instead of `$.File` to correctly reference the current violation's file field in the iteration context.

### Changes Made
**File:** `internal/reporters/templates/report.html` (line 909)
```html
<!-- Before -->
<pre class="code-snippet border rounded p-2"><code class="language-{{ detectLanguage $.File }}">{{ formatCode .CodeSnippet }}</code></pre>

<!-- After -->
<pre class="code-snippet border rounded p-2"><code class="language-{{ detectLanguage .File }}">{{ formatCode .CodeSnippet }}</code></pre>
```

### Testing
- HTML report generation now works correctly
- The generated HTML files are complete and properly formatted
- Language detection for code snippets functions as expected

---

## Issue 3: Potential Deadlock in Scanner Engine Error Handling

### Problem
The scanner engine had a potential deadlock condition when processing files with many parse errors. Workers would send errors to `errorsChan` before sending results to `resultsChan`, but the main goroutine processed results first and only drained errors after results were complete. Under high error rates, `errorsChan` could fill up and block workers, preventing them from completing and creating a deadlock.

### Root Cause
In `internal/scanner/engine.go`, the worker function would:
1. Send error to `errorsChan` (line 280) - could block if channel is full
2. Send result to `resultsChan` (line 284) - blocked until step 1 completes

The main goroutine would:
1. Process all results from `resultsChan` (lines 229-236)
2. Only then process errors from `errorsChan` (lines 239-241)

This created a circular dependency where workers couldn't complete their work because they were blocked on error sending, but the main goroutine couldn't drain errors because it was waiting for results.

### Solution
Reordered operations in the worker function to:
1. Always send result first (non-blocking)
2. Send error with non-blocking select/default pattern

This ensures workers never get blocked and can always complete their work. Error information is still preserved in `result.File.Error` even if the error channel is full.

### Changes Made
**File:** `internal/scanner/engine.go` (lines 271-296)
```go
result, err := e.parser.ParseFile(file)
if err != nil {
    file.Error = err.Error()
    file.Scanned = false
    result = &models.ScanResult{
        File:       file,
        Violations: []*models.Violation{},
        Metrics:    &models.FileMetrics{},
    }
} else {
    e.violationDetector.DetectViolations(result)
}

// Always send result first to avoid blocking on the errors channel
resultsChan <- result

// Send error non-blocking (best-effort error reporting)
if err != nil {
    select {
    case errorsChan <- fmt.Errorf("failed to parse %s: %w", file.Path, err):
        // Error successfully sent to error channel
    default:
        // Error channel is full, but error is already recorded in result.File.Error
        // so we can safely drop this duplicate error report
    }
}
```

### Testing
- Manual testing with files containing syntax errors confirmed no deadlock
- Added `TestScanFilesWithErrorsNoDeadlock` test case to prevent regression
- Test creates 50 files with intentional syntax errors and verifies scan completes within 30 seconds

---

## Impact
These fixes resolve critical issues:
1. Users can now properly generate JSON reports using the CLI, which is important for programmatic processing and CI/CD integration
2. HTML report generation is restored, allowing users to view interactive reports in their browsers
3. Scanner engine is now deadlock-free when processing files with syntax errors, ensuring reliable operation on large codebases with mixed code quality

## Prevention
To prevent similar issues in the future:
1. Ensure all command-line flags mentioned in help text are properly implemented
2. Add integration tests for all output formats
3. Test template changes with actual data before committing
4. Consider adding template validation during the build process